/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "string.h"
#include "stdio.h"

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;

UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
static const uint8_t MPU9250_AD = 0x68 << 1; //Converte o endereço de 7 bits para 8 bits
static const uint8_t MAG_AD = 0x0C << 1;
static const uint8_t BMP_AD = 0x77 << 1;//Endereço do bmp180; pag.20 do datasheet

static const uint8_t ACE_CONFIG_AD = 0x1C ;
static const uint8_t GIR_CONFIG_AD = 0x1B ;
//static const uint8_t USER_CTRL = 0x6A ;
static const uint8_t INT_BYPASS_CONFIG = 0x37;
static const uint8_t PWR_MGMT_1 = 0x6B ;
static const uint8_t CNTL1 = 0x0A ;
static const uint8_t ACE_XOUT_H = 0x3B ;
static const uint8_t MAG_XOUT_L = 0x03 ;
static const uint8_t TEMP_CONTROL_REG_AD = 0x2E ; //Endereço do "control register" da temperatura; pag.21 do datasheet
static const uint8_t PRE_CONTROL_REG_AD = 0xB4 ; //Endereço do "control register" da pressão; pag.21 do datasheet
static const uint8_t BMP_REG_AD = 0xF4 ; //Endereço do "register"; pag.21 do datasheet
static const uint8_t AC1_MSB = 0xAA ; //Endereço do msb do primeiro valor do e2prom; pag.13 do datasheet
static const uint8_t XG_OFFSET_H = 0x13 ; //Endereço dos registradores de offset do giroscópio; register map - p. 7
static const uint8_t XG_OFFSET_L = 0x14 ;
static const uint8_t YG_OFFSET_H = 0x15 ;
static const uint8_t YG_OFFSET_L = 0x16 ;
static const uint8_t ZG_OFFSET_H = 0x17 ;
static const uint8_t ZG_OFFSET_L = 0x18 ;
static const uint8_t XA_OFFSET_H = 0x77 ; //Endereço dos registradores de offset do acelerômetro; register map - p. 9
static const uint8_t XA_OFFSET_L = 0x78 ;
static const uint8_t YA_OFFSET_H = 0x7A ;
static const uint8_t YA_OFFSET_L = 0x7B ;
static const uint8_t ZA_OFFSET_H = 0x7C ;
static const uint8_t ZA_OFFSET_L = 0x7D ;
static const uint8_t MAG_ASAX = 0x10 ; //Endereço dos registradores de ajuste de sensibilidade; register map - p. 47
static const uint8_t MAG_ASAY = 0x11 ;
static const uint8_t MAG_ASAZ = 0x12 ;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART2_UART_Init(void);

/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	HAL_StatusTypeDef ret;
	uint8_t buf[22];
	uint8_t msg[1000];
	int16_t data[6];  //Valores lidos dos sensores em 16 bits
	int8_t magSensi[3];
	int16_t e2prom[11];//Valores do e2prom do sensor bmp180 em 16 bites

	const float aRes = 8.0 / 32768.0;
	const float gRes = 1000.0 / 32768.0;
	float ax, ay, az, gx, gy, gz, t, mx, my, mz, Temp, ax_off, ay_off, az_off, gx_off, gy_off, gz_off, mx_off, my_off, mz_off;
	long int UT, UP, X1, X2, X3, B3, B4, B5, B6, B7, P;
	int j, k;

	//Configurações Acelerômetro
	buf[0] = ACE_CONFIG_AD;
	buf[1] = 0x10; // 0x10 configura o range para +-8g
	HAL_I2C_Master_Transmit(&hi2c1, MPU9250_AD, buf, 2, 100);

	//Configurações Giroscópio
	buf[0] = GIR_CONFIG_AD;
	buf[1] = 0x11; // Configura o range para +-1000 dps e Fchoice 01
	fs_sel = 2;
	HAL_I2C_Master_Transmit(&hi2c1, MPU9250_AD, buf, 2, 100);
	buf[0] = PWR_MGMT_1;
	buf[2] = 0x01 ; // Define a referência do clock como o eixo x
	HAL_I2C_Master_Transmit(&hi2c1, MPU9250_AD, buf, 2, 100);

	//Configurações Magnetômetro
	buf[0] = INT_BYPASS_CONFIG ;
	buf[1] = 0x02 ; // Liga o bypass multiplex
	HAL_I2C_Master_Transmit(&hi2c1, MPU9250_AD, buf, 2, 100);
	buf[0] = CNTL1;
	buf[1] = 0x1F;
	HAL_I2C_Master_Transmit(&hi2c1, MAG_AD, buf, 2, 100);
	buf[0] = MAG_ASAX;
	HAL_I2C_Master_Transmit(&hi2c1, MAG_AD, buf, 1, 100);
	HAL_I2C_Master_Receive(&hi2c1, MAG_AD, buf, 3, 100); // Lendo a sensibilidade do magnetômetro
	magSensi[0] = (float) buf[0];
	magSensi[1] = (float) buf[1];
	magSensi[2] = (float) buf[2];
	HAL_Delay(100);

	//Configurações Bmp180
	buf[0] = BMP_REG_AD;
	buf[1] = PRE_CONTROL_REG_AD;
	buf[2] = TEMP_CONTROL_REG_AD;
	HAL_I2C_Master_Transmit(&hi2c1, BMP_AD, buf, 3, 100);//Iniciando o sensor
	buf[0] = AC1_MSB;
	HAL_I2C_Master_Receive(&hi2c1, BMP_AD, buf, 22, 100);//Lendo os valores do e2prom e armazenando-os em um vetor chamado e2prom[]
	for (int i=0;i<11;i++) {
		 //Lógica usada para os valores de j e k
	     // e[0] = 0 + 1
		 // e[1] = 2 + 3
		 // e[2] = 4 + 5
		j = i*2;
		k = (i*2)+1;
		e2prom[i] = (int16_t)(((int16_t)buf[j] << 8)  | buf[k]) ;//Turn the MSB and LSB into a signed 16-bit value
	}


  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USART2_UART_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
  	//LEITURA OFFSET
	
	//GIROSCÓPIO - ORDEM - X, Y, Z
	buf[0] = XG_OFFSET_H ;
	ret = HAL_I2C_Master_Transmit(&hi2c1,MPU9250_AD,buf,1,100) ;
	if (ret != HAL_OK){
		strcpy((char*)msg,"Error Tx\r\n") ;
	}
	else{
		ret = HAL_I2C_Master_Receive(&hi2c1,MPU9250_AD,buf,6,100) ;
		if (ret != HAL_OK){
			strcpy((char*)msg,"Error Rx\r\n") ;
		}
		else{
			data[0] = (int16_t)(((int16_t)buf[0] << 8)  | buf[1]) ;  // Turn the MSB and LSB into a signed 16-bit value
			data[1] = (int16_t)(((int16_t)buf[2] << 8)  | buf[3]) ;
			data[2] = (int16_t)(((int16_t)buf[4] << 8)  | buf[5]) ;
			
			gx_off = data[0] * gRes;
			gy_off = data[0] * gRes;
			gz_off = data[0] * gRes;
			
			sprintf((char*)msg,"gx_off=%f  gy_off=%f  gz_off=%f  [degrees/s]", gx_off,gy_off,gz_off);
		}
	}
			
	//ACELERÔMETRO - ORDEM - X, Y, Z
	buf[0] = XA_OFFSET_H ;
	ret = HAL_I2C_Master_Transmit(&hi2c1,MPU9250_AD,buf,1,100) ;
	if (ret != HAL_OK){
		strcpy((char*)msg,"Error Tx\r\n") ;
	}
	else{
		ret = HAL_I2C_Master_Receive(&hi2c1,MPU9250_AD,buf,6,100) ;
		if (ret != HAL_OK){
			strcpy((char*)msg,"Error Rx\r\n") ;
		}
		else{
			data[0] = (int16_t)(((int16_t)buf[0] << 8)  | buf[1]) ;  // Turn the MSB and LSB into a signed 16-bit value
			data[1] = (int16_t)(((int16_t)buf[2] << 8)  | buf[3]) ;
			data[2] = (int16_t)(((int16_t)buf[4] << 8)  | buf[5]) ;
			
			ax_off = data[0] * aRes;
			ay_off = data[0] * aRes;
			az_off = data[0] * aRes;
			
			sprintf((char*)msg,"ax_off=%f  ay_off=%f  az_off=%f  [degrees/s]", ax_off,ay_off,az_off);
		}
	}
			
			
				
	//MAGNETÔMETRO - ORDEM - X, Y, Z
	buf[0] = MAG_ASAX ;
	ret = HAL_I2C_Master_Transmit(&hi2c1,MPU9250_AD,buf,1,100) ;
	if (ret != HAL_OK){
		strcpy((char*)msg,"Error Tx\r\n") ;
	}
	else{
		ret = HAL_I2C_Master_Receive(&hi2c1,MPU9250_AD,buf,6,100) ;
		if (ret != HAL_OK){
			strcpy((char*)msg,"Error Rx\r\n") ;
		}
		else{
			data[0] = (float) buf[0] ; 
			data[1] = (float) buf[2] ;
			data[2] = (float) buf[4] ;
			
			mx = (float) data[0] *((magSensi[0] - 128)*0.5/128 + 1);
			my = (float) data[1] *((magSensi[1] - 128)*0.5/128 + 1);
			mz = (float) data[2] *((magSensi[2] - 128)*0.5/128 + 1);

			sprintf((char*)msg,"mx_off=%f   my_off=%f   mz_off=%f\r\n",mx_off,my_off,mz_off);
		}
	}
				
	//Leitura do acelerômetro, termômetro e giroscópio
	buf[0] = ACE_XOUT_H;
	ret = HAL_I2C_Master_Transmit(&hi2c1,MPU9250_AD,buf,1,100);
	if (ret != HAL_OK){
		strcpy((char*)msg,"Error Tx\r\n");
	}
	else{
		ret = HAL_I2C_Master_Receive(&hi2c1,MPU9250_AD,buf,14,100);
		if (ret != HAL_OK){
			strcpy((char*)msg,"Error Rx\r\n");
		}
		else{
			data[0] = (int16_t)(((int16_t)buf[0] << 8)  | buf[1]) ;  // Turn the MSB and LSB into a signed 16-bit value
			data[1] = (int16_t)(((int16_t)buf[2] << 8)  | buf[3]) ;
			data[2] = (int16_t)(((int16_t)buf[4] << 8)  | buf[5]) ;
			data[3] = (int16_t)(((int16_t)buf[6] << 8)  | buf[7]) ;
			data[4] = (int16_t)(((int16_t)buf[8] << 8)  | buf[9]) ;
			data[5] = (int16_t)(((int16_t)buf[10] << 8) | buf[11]);
			data[6] = (int16_t)(((int16_t)buf[12] << 8) | buf[13]);

			ax = (float) data[0] * aRes;
			ay = (float) data[1] * aRes;
			az = (float) data[2] * aRes;

			t = ((float) data[3] - 21.0)/333.87 + 21.0;

			gx = (float) data[4] * gRes;
			gy = (float) data[5] * gRes;
			gz = (float) data[6] * gRes;

			sprintf((char*)msg," ax=%f  ay=%f  az=%f  [m/s^2]\n gx=%f  gy=%f  gz=%f  [degrees/s]\n t=%f[ºC]\n",ax,ay,az,gx,gy,gz,t);
		}
	}
	HAL_UART_Transmit(&huart2, msg, sizeof(msg), 100);

	//Leitura Magnetômetro
	buf[0] = MAG_XOUT_L;
	ret = HAL_I2C_Master_Transmit(&hi2c1,MAG_AD,buf,1,100);
	if (ret != HAL_OK){
			strcpy((char*)msg,"Error Mag Tx\r\n");
		}
		else{
			ret = HAL_I2C_Master_Receive(&hi2c1,MAG_AD,buf,6,100);
			if (ret != HAL_OK){
				strcpy((char*)msg,"Error Mag Rx\r\n");
			}
			else{
				data[0] = (int16_t)(((int16_t)buf[1] << 8)  | buf[0]);  // Turn the MSB and LSB into a signed 16-bit value
				data[1] = (int16_t)(((int16_t)buf[3] << 8)  | buf[2]);
				data[2] = (int16_t)(((int16_t)buf[5] << 8)  | buf[4]);

				mx = (float) data[0] *((magSensi[0] - 128)*0.5/128 + 1);
				my = (float) data[1] *((magSensi[1] - 128)*0.5/128 + 1);
				mz = (float) data[2] *((magSensi[2] - 128)*0.5/128 + 1);

				sprintf((char*)msg,"mx=%f   my=%f   mz=%f\r\n",mx,my,mz);
			}
		}
	HAL_UART_Transmit(&huart2, msg, sizeof(msg), 100);
	HAL_Delay(100);

	//**************************************************************************
	
	//Leitura da temperatura descompensada (UT)
	buf[0] = TEMP_CONTROL_REG_AD;
	ret = HAL_I2C_Master_Transmit(&hi2c1,BMP_REG_AD,buf,1,100);
	HAL_Delay(5);
	if (ret != HAL_OK){
		strcpy((char*)msg,"Error Tx temperatura\r\n");
	}
	else{
		buf[0] = 0xF6;
		ret = HAL_I2C_Master_Receive(&hi2c1,BMP_AD,buf,2,100);
			if (ret != HAL_OK){
				strcpy((char*)msg,"Error Rx temperatura\r\n");
			}
			else{
				UT = (int16_t)(((int16_t)buf[0] << 8)  | buf[1]) ; //Turn the MSB and LSB into a signed 16-bit value
				X1 = (UT-e2prom[5])*e2prom[4]/(2^15);//32768
				X2 = e2prom[9]*2^11/(X1+e2prom[10]);
				B5 = X1+X2;
				Temp = ((B5+8)/(2^4))/10;
				//Ver se ^ funciona
				sprintf((char*)msg,"A temperatura e: %f\r\n",Temp);
			}
	}
	HAL_UART_Transmit(&huart2, msg, sizeof(msg), 100);
	HAL_Delay(100);

	//Leitura da pressão descompensada
	buf[0] = (int16_t)(((int16_t)0x34) | PRE_CONTROL_REG_AD << 6);
	ret = HAL_I2C_Master_Transmit(&hi2c1,BMP_REG_AD,buf,1,100);
	HAL_Delay(14);
	if (ret != HAL_OK){
		strcpy((char*)msg,"Error Tx pressao\r\n");
	}
	else{
		buf[0] = 0xF6;
		ret = HAL_I2C_Master_Receive(&hi2c1,BMP_AD,buf,3,100);
			if (ret != HAL_OK){
				strcpy((char*)msg,"Error Rx pressao\r\n");
			}
			else{
				UP = (int16_t)(((int16_t)buf[0] << 16)  | buf[1] << 8 | buf[2]) >> (8-2); //Junta o MSB, o LSB e o XLSB em um único número de 24 bits
				B6 = B5-4000;
				X1 = (e2prom[7]*(B6*B6/2^12))/(2^11);
				X2 = e2prom[1]*B6/(2^11);
				X3 = X1 + X2;
				B3 = (((e2prom[0]*4+X3)<<2)+2)/4;
				X1 = e2prom[2]*B6/(2^13);
				X2 = (e2prom[6]*(B6*B6/2^12))/(2^16);
				X3 = ((X1+X2)+2)/4;
				B4 = e2prom[3]*(unsigned long)(X3+32768)/(2^15);
				B7 = ((unsigned long)UP-B3)*(50000>>2);
				if(B7<0x80000000){
					P = (B7*2)/B4;
				}else{
					P = (B7/B4)*2;
				}
				X1 = (P/2^8)*(P/2^8);
				X1 = (X1*3038)/(2^16);
				X2 = (-7357*P)/(2^16);
				P = P+(X1+X2+3791)/(2^4);
				sprintf((char*)msg,"A pressao e: %ld\r\n",P);
			}
	}
	HAL_UART_Transmit(&huart2, msg, sizeof(msg), 100);
	HAL_Delay(100);

  }



    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/*void write_register(uint8_t register_pointer, uint16_t register_value)
{
    uint8_t data[3];

    data[0] = register_pointer;
    data[1] = register_value>>8;    // MSB byte of 16bit data
    data[2] = register_value;       // LSB byte of 16bit data

    HAL_I2C_Master_Transmit(&hi2c1, MPU9250_ADDR, data, 3, 1000);  // data is the start pointer of our array
}

void read_register(uint8_t register_pointer, uint8_t* receive_buffer)
{
    // first set the register pointer to the register wanted to be read
    HAL_I2C_Master_Transmit(&hi2c1, MPU9250_ADDR, &register_pointer, 1, 1000);  // note the & operator which gives us the address of the register_pointer variable

    // receive the 2 x 8bit data into the receive buffer
    HAL_I2C_Master_Receive(&hi2c1, MPU9250_ADDR, receive_buffer, 2, 1000);
}


  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/*void SPrint(UART_HandleTypeDef *huart, char _out[])
{
  HAL_UART_Transmit(huart, (uint8_t *) _out, strlen(_out), 10);
}

void SPrintln(UART_HandleTypeDef *huart, char _out[])
{
  HAL_UART_Transmit(huart, (uint8_t *) _out, strlen(_out), 10);
  char newline[2] = "\r\n";
  HAL_UART_Transmit(huart, (uint8_t *) newline, 2, 10);
}


  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

